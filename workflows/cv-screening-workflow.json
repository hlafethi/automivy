{
  "name": "CV Screening with OpenRouter AI",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "cv-screening",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger-cv",
      "name": "Webhook Trigger (AUTOMIVY)",
      "type": "n8n-nodes-base.webhook",
      "position": [250, 300],
      "webhookId": "cv-screening-webhook-automivy",
      "typeVersion": 1.1,
      "disabled": false
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// NODE 1: PREPARE CV DATA (Remplace le node existant)\n// =====================================================\nconst webhookData = $input.item.json;\n\nconsole.log('üöÄ [PREPARE CV] Starting...');\nconsole.log('üì¶ [PREPARE CV] Webhook keys:', Object.keys(webhookData));\n\nconst body = webhookData.body || webhookData;\nconsole.log('üì¶ [PREPARE CV] Body keys:', body ? Object.keys(body) : 'NO BODY');\n\nconst metadata = {\n  fullName: body?.fullName || body?.name || webhookData.fullName || webhookData.name || 'Candidat Inconnu',\n  email: body?.email || webhookData.email || 'no-email@example.com',\n  jobRequirements: body?.jobRequirements || webhookData.jobRequirements || 'Crit√®res non sp√©cifi√©s',\n  notificationEmail: body?.notificationEmail || body?.email || webhookData.notificationEmail || webhookData.email || ''\n};\n\nconsole.log('üë§ [PREPARE CV] Metadata:', metadata);\n\nfunction extractBase64FromInput(input, fieldName) {\n  if (!input) return null;\n  const inputType = typeof input;\n  console.log(`üîç [PREPARE CV] Checking ${fieldName}, type: ${inputType}`);\n  if (inputType === 'string') {\n    if (input.startsWith('data:')) {\n      const match = input.match(/^data:([^;]+);base64,(.+)$/);\n      if (match) {\n        console.log(`‚úÖ [PREPARE CV] Data URL found in ${fieldName}, mime: ${match[1]}`);\n        return { base64: match[2], mimeType: match[1] };\n      }\n    }\n    if (input.length > 100 && !/[:/]/.test(input.substring(0, 50))) {\n      console.log(`‚úÖ [PREPARE CV] Pure base64 found in ${fieldName}`);\n      return { base64: input, mimeType: 'application/pdf' };\n    }\n    if (input.startsWith('http')) {\n      console.warn(`‚ö†Ô∏è [PREPARE CV] HTTP URL in ${fieldName} - use web_fetch node`);\n      return null;\n    }\n  }\n  if (inputType === 'object' && input !== null) {\n    const dataProps = ['data', 'content', 'base64', 'url'];\n    for (const prop of dataProps) {\n      if (input[prop]) {\n        const result = extractBase64FromInput(input[prop], `${fieldName}.${prop}`);\n        if (result) return result;\n      }\n    }\n  }\n  return null;\n}\n\nlet cvData = null;\nconst searchSources = [{ obj: body, name: 'body' }, { obj: webhookData, name: 'webhookData' }];\nconst searchFields = ['cvUrl', 'cv_url', 'cvFile', 'cv_file', 'cv', 'file', 'data', 'attachment', 'document', 'resume'];\n\nfor (const source of searchSources) {\n  if (cvData) break;\n  if (!source.obj) continue;\n  for (const field of searchFields) {\n    if (source.obj[field]) {\n      cvData = extractBase64FromInput(source.obj[field], `${source.name}.${field}`);\n      if (cvData) break;\n    }\n  }\n}\n\nif (!cvData) {\n  const cvFilesRaw = body?.cvFiles || webhookData.cvFiles;\n  if (cvFilesRaw) {\n    console.log('üîç [PREPARE CV] Checking cvFiles...');\n    let cvFilesArray = [];\n    if (Array.isArray(cvFilesRaw)) {\n      cvFilesArray = cvFilesRaw;\n    } else if (typeof cvFilesRaw === 'object') {\n      cvFilesArray = Object.values(cvFilesRaw);\n    } else if (typeof cvFilesRaw === 'string') {\n      try {\n        const parsed = JSON.parse(cvFilesRaw);\n        cvFilesArray = Array.isArray(parsed) ? parsed : [parsed];\n      } catch (e) {\n        console.error('‚ùå [PREPARE CV] cvFiles parse error:', e.message);\n      }\n    }\n    console.log(`üìã [PREPARE CV] cvFiles array length: ${cvFilesArray.length}`);\n    for (let i = 0; i < cvFilesArray.length; i++) {\n      const file = cvFilesArray[i];\n      if (file && typeof file === 'object') {\n        cvData = extractBase64FromInput(file, `cvFiles[${i}]`);\n        if (cvData) {\n          if (file.name) metadata.cvName = file.name;\n          if (file.mimeType) cvData.mimeType = file.mimeType;\n          break;\n        }\n      }\n    }\n  }\n}\n\nif (!cvData) {\n  console.error('‚ùå [PREPARE CV] NO CV FOUND');\n  console.error('üì¶ Full webhook data:', JSON.stringify(webhookData, null, 2).substring(0, 2000));\n  throw new Error(`NO_CV_FOUND: Aucun CV d√©tect√© dans le payload webhook. Fields re√ßus: ${Object.keys(body || webhookData).join(', ')}`);\n}\n\nconsole.log('‚úÖ [PREPARE CV] CV extracted successfully');\nconsole.log(`üìÑ [PREPARE CV] MIME type: ${cvData.mimeType}`);\nconsole.log(`üìä [PREPARE CV] Base64 length: ${cvData.base64.length} chars`);\nconsole.log(`üîç [PREPARE CV] Base64 preview: ${cvData.base64.substring(0, 80)}...`);\n\nreturn {\n  json: {\n    ...metadata,\n    success: true,\n    cvExtracted: true,\n    base64Length: cvData.base64.length\n  },\n  binary: {\n    data: {\n      data: cvData.base64,\n      mimeType: cvData.mimeType,\n      fileName: metadata.cvName || 'CV.pdf',\n      fileExtension: (metadata.cvName || 'CV.pdf').split('.').pop()\n    }\n  }\n};"
      },
      "id": "prepare-cv-data",
      "name": "Prepare CV Data",
      "type": "n8n-nodes-base.code",
      "position": [500, 300],
      "typeVersion": 2,
      "disabled": false
    },
    {
      "parameters": {
        "binaryPropertyName": "data",
        "options": {
          "stripBOM": false
        }
      },
      "id": "extract-from-file",
      "name": "Extract PDF Text",
      "type": "n8n-nodes-base.extractFromFile",
      "position": [750, 300],
      "typeVersion": 1,
      "disabled": false
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// NODE 2: NORMALIZE EXTRACTED TEXT (apr√®s Extract PDF Text)\n// =====================================================\nconst allItems = $input.all();\nconsole.log(`üì• [NORMALIZE] Received ${allItems.length} items`);\n\nlet fullText = '';\n\nfunction cleanText(text) {\n  if (!text || typeof text !== 'string') return '';\n  return text\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x9F]/g, '')\n    .replace(/[ \\t]+/g, ' ')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n}\n\nfunction isTextQualityGood(text) {\n  if (!text || text.length < 50) return false;\n  \n  // V√©rifier la pr√©sence de mots significatifs (plus de 3 caract√®res)\n  const words = text.split(/\\s+/).filter(w => w.length > 3);\n  if (words.length < 10) return false;\n  \n  // V√©rifier la pr√©sence de caract√®res alphanum√©riques\n  const alphanumericRatio = (text.match(/[a-zA-Z0-9]/g) || []).length / text.length;\n  if (alphanumericRatio < 0.3) return false;\n  \n  // V√©rifier la pr√©sence de caract√®res sp√©ciaux typiques d'un CV (majuscules, chiffres)\n  const hasCapitalLetters = /[A-Z]/.test(text);\n  const hasNumbers = /[0-9]/.test(text);\n  \n  return hasCapitalLetters && hasNumbers;\n}\n\nfunction findTextInItem(item) {\n  if (item.binary?.data?.data) {\n    const bData = item.binary.data.data;\n    if (Buffer.isBuffer(bData)) {\n      return bData.toString('utf8');\n    }\n    if (typeof bData === 'string') {\n      return bData;\n    }\n  }\n  const searchKeys = ['data', 'text', 'content', 'output'];\n  for (const key of searchKeys) {\n    if (item.json?.[key] && typeof item.json[key] === 'string') {\n      return item.json[key];\n    }\n  }\n  return '';\n}\n\nfor (let i = 0; i < allItems.length; i++) {\n  const itemText = findTextInItem(allItems[i]);\n  const cleaned = cleanText(itemText);\n  if (cleaned.length > 10) {\n    fullText += (fullText ? '\\n\\n' : '') + cleaned;\n    console.log(`‚úÖ [NORMALIZE] Item ${i+1}: ${cleaned.length} chars`);\n  } else {\n    console.warn(`‚ö†Ô∏è [NORMALIZE] Item ${i+1}: texte invalide (${cleaned.length} chars)`);\n  }\n}\n\nfullText = cleanText(fullText);\n\nconsole.log(`üìä [NORMALIZE] Total text: ${fullText.length} chars`);\nconsole.log(`üîç [NORMALIZE] Preview: ${fullText.substring(0, 200)}`);\n\n// D√©tection am√©lior√©e : v√©rifier la qualit√© du texte, pas seulement la longueur\nconst textQualityGood = isTextQualityGood(fullText);\nconst needsOCR = !fullText || fullText.length < 50 || !textQualityGood;\n\nconsole.log(`üîî [NORMALIZE] Text quality good: ${textQualityGood}`);\nconsole.log(`üîî [NORMALIZE] Needs OCR: ${needsOCR}`);\n\nconst result = {\n  json: {\n    text: fullText,\n    textLength: fullText.length,\n    needsOCR: needsOCR,\n    extractionMethod: 'extractFromFile',\n    textQualityGood: textQualityGood\n  },\n  pairedItem: allItems[0]?.pairedItem\n};\n\nif (allItems[0]?.binary && typeof allItems[0].binary === 'object') {\n  result.binary = allItems[0].binary;\n}\n\nreturn result;"
      },
      "id": "normalize-extracted-text",
      "name": "Normalize Extracted Text",
      "type": "n8n-nodes-base.code",
      "position": [875, 300],
      "typeVersion": 2,
      "disabled": false
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-needs-ocr",
              "leftValue": "={{ $json.needsOCR }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "check-needs-ocr",
      "name": "Check Needs OCR",
      "type": "n8n-nodes-base.if",
      "position": [1000, 300],
      "typeVersion": 2,
      "disabled": false
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// NODE 3: PREPARE OCR - Convert PDF to images\n// =====================================================\nconst normalizedData = $('Normalize Extracted Text').item.json;\nconst preparedData = $('Prepare CV Data').item.json;\nconst originalBinary = $('Prepare CV Data').item.binary;\n\nconsole.log('üîÑ [PREPARE OCR] Starting PDF to images conversion...');\n\nlet pdfBase64 = '';\n\nif (originalBinary?.data?.data) {\n  const bData = originalBinary.data.data;\n  if (Buffer.isBuffer(bData)) {\n    pdfBase64 = bData.toString('base64');\n  } else if (typeof bData === 'string') {\n    pdfBase64 = bData;\n  }\n}\n\nif (!pdfBase64 || pdfBase64.length < 100) {\n  throw new Error('PREPARE_OCR_ERROR: PDF non disponible pour OCR');\n}\n\nconsole.log(`‚úÖ [PREPARE OCR] PDF ready: ${pdfBase64.length} chars`);\n\n// OCR.space accepte les PDFs en base64 directement\nreturn {\n  json: {\n    pdfBase64: pdfBase64,\n    pdfDataUrl: `data:application/pdf;base64,${pdfBase64}`,\n    fullName: preparedData.fullName,\n    email: preparedData.email,\n    jobRequirements: preparedData.jobRequirements,\n    notificationEmail: preparedData.notificationEmail\n  }\n};"
      },
      "id": "prepare-ocr",
      "name": "Prepare OCR",
      "type": "n8n-nodes-base.code",
      "position": [1125, 200],
      "typeVersion": 2,
      "disabled": false
    },
    {
      "parameters": {
        "url": "https://api.ocr.space/parse/image",
        "method": "POST",
        "sendBody": true,
        "contentType": "application/x-www-form-urlencoded",
        "bodyParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "K88809787888957"
            },
            {
              "name": "base64Image",
              "value": "={{ $json.pdfBase64 }}"
            },
            {
              "name": "filetype",
              "value": "PDF"
            },
            {
              "name": "language",
              "value": "fre"
            },
            {
              "name": "isOverlayRequired",
              "value": "false"
            },
            {
              "name": "detectOrientation",
              "value": "true"
            }
          ]
        },
        "options": {}
      },
      "id": "ocr-with-vision",
      "name": "OCR with OCR.space",
      "type": "n8n-nodes-base.httpRequest",
      "position": [1250, 200],
      "typeVersion": 4.2,
      "disabled": false
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// NODE 4: PARSE OCR RESULT (apr√®s OCR with OCR.space)\n// =====================================================\nconst ocrResponse = $input.item.json;\nconst prepareOcrData = $('Prepare OCR').item.json;\n\nconsole.log('üîç [PARSE OCR] Parsing OCR.space response...');\nconsole.log('üîç [PARSE OCR] Response keys:', Object.keys(ocrResponse));\n\nlet extractedText = '';\n\ntry {\n  // OCR.space retourne le texte dans ParsedResults[0].ParsedText\n  if (ocrResponse.ParsedResults && ocrResponse.ParsedResults.length > 0) {\n    extractedText = ocrResponse.ParsedResults[0].ParsedText || '';\n    console.log('‚úÖ [PARSE OCR] Found text in ParsedResults[0].ParsedText');\n  } else if (ocrResponse.ParsedText) {\n    extractedText = ocrResponse.ParsedText;\n    console.log('‚úÖ [PARSE OCR] Found text in ParsedText');\n  } else if (ocrResponse.text) {\n    extractedText = ocrResponse.text;\n    console.log('‚úÖ [PARSE OCR] Found text in text');\n  } else if (typeof ocrResponse === 'string') {\n    extractedText = ocrResponse;\n    console.log('‚úÖ [PARSE OCR] Response is string');\n  } else {\n    console.error('‚ùå [PARSE OCR] Response structure:', JSON.stringify(ocrResponse).substring(0, 500));\n    \n    // V√©rifier s'il y a une erreur\n    if (ocrResponse.ErrorMessage) {\n      throw new Error(`OCR.space error: ${ocrResponse.ErrorMessage}`);\n    }\n    \n    throw new Error('OCR response structure invalid - no text found');\n  }\n  \n  if (!extractedText || extractedText.trim().length === 0) {\n    throw new Error('OCR returned empty text');\n  }\n  \n} catch (e) {\n  console.error('‚ùå [PARSE OCR] Error:', e.message);\n  console.error('‚ùå [PARSE OCR] Full response:', JSON.stringify(ocrResponse).substring(0, 1000));\n  throw new Error(`PARSE_OCR_ERROR: ${e.message}`);\n}\n\nfunction cleanText(text) {\n  if (!text || typeof text !== 'string') return '';\n  return text\n    .replace(/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x9F]/g, '')\n    .replace(/[ \\t]+/g, ' ')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n}\n\nextractedText = cleanText(extractedText);\n\nconsole.log(`‚úÖ [PARSE OCR] Extracted: ${extractedText.length} chars`);\nconsole.log(`üîç [PARSE OCR] Preview: ${extractedText.substring(0, 300)}`);\n\nif (extractedText.length < 50) {\n  console.warn('‚ö†Ô∏è [PARSE OCR] Extracted text is very short, OCR may have failed');\n}\n\nreturn {\n  json: {\n    text: extractedText,\n    textLength: extractedText.length,\n    extractionMethod: 'ocr-space',\n    fullName: prepareOcrData.fullName,\n    email: prepareOcrData.email,\n    jobRequirements: prepareOcrData.jobRequirements,\n    notificationEmail: prepareOcrData.notificationEmail\n  }\n};"
      },
      "id": "parse-ocr-result",
      "name": "Parse OCR Result",
      "type": "n8n-nodes-base.code",
      "position": [1375, 200],
      "typeVersion": 2,
      "disabled": false
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// NODE 5: MERGE TEXT RESULTS\n// =====================================================\nconst allItems = $input.all();\nconsole.log(`üì• [MERGE] Merging ${allItems.length} items...`);\n\nlet bestText = '';\nlet bestMethod = 'unknown';\nlet metadata = {};\n\nfor (const item of allItems) {\n  const itemText = item.json.text || item.json.data || '';\n  if (itemText.length > bestText.length) {\n    bestText = itemText;\n    bestMethod = item.json.extractionMethod || 'unknown';\n  }\n  if (item.json.fullName) metadata.fullName = item.json.fullName;\n  if (item.json.email) metadata.email = item.json.email;\n  if (item.json.jobRequirements) metadata.jobRequirements = item.json.jobRequirements;\n  if (item.json.notificationEmail) metadata.notificationEmail = item.json.notificationEmail;\n}\n\nif (!metadata.fullName) {\n  const preparedData = $('Prepare CV Data').item.json;\n  metadata = {\n    fullName: preparedData.fullName || 'Candidat Inconnu',\n    email: preparedData.email || 'no-email@example.com',\n    jobRequirements: preparedData.jobRequirements || 'Non sp√©cifi√©',\n    notificationEmail: preparedData.notificationEmail || preparedData.email\n  };\n}\n\nconsole.log(`‚úÖ [MERGE] Best text: ${bestText.length} chars via ${bestMethod}`);\n\nreturn {\n  json: {\n    text: bestText,\n    textLength: bestText.length,\n    extractionMethod: bestMethod,\n    ...metadata\n  }\n};"
      },
      "id": "merge-text-results",
      "name": "Merge Text Results",
      "type": "n8n-nodes-base.code",
      "position": [1500, 300],
      "typeVersion": 2,
      "disabled": false
    },
    {
      "parameters": {
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "method": "POST",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openRouterApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "openai/gpt-4o-mini"
            },
            {
              "name": "messages",
              "value": "={{ (() => {\n  // Utiliser le texte fusionn√© depuis Merge Text Results\n  const mergedData = $input.item.json;\n  const cvText = mergedData.text || mergedData.data || '';\n  const textLength = mergedData.textLength || 0;\n  const extractionMethod = mergedData.extractionMethod || 'unknown';\n  \n  // R√©cup√©rer les donn√©es du candidat\n  const preparedData = $('Prepare CV Data').item.json;\n  \n  // Si le texte est vide ou trop court, informer l'AI\n  if (!cvText || textLength < 50) {\n    return [{ role: 'user', content: `Tu es un Assistant RH IA. Un CV a √©t√© soumis mais l'extraction du texte a √©chou√© m√™me apr√®s tentative OCR.\n\n**Probl√®me:**\nLe texte du CV est vide ou trop court (moins de 50 caract√®res) apr√®s extraction standard et OCR.\n\n**Candidat:** ${preparedData.fullName}\n**Email:** ${preparedData.email}\n**Exigences du poste:** ${preparedData.jobRequirements}\n\n**Instructions:**\nPuisqu'aucun texte lisible n'a √©t√© extrait du CV, fournis une explication claire en fran√ßais que:\n1. Le PDF n'a pas pu √™tre analys√© car il semble √™tre scann√© (image) ou corrompu\n2. Le candidat doit soumettre un PDF avec texte s√©lectionnable\n3. Le score est 0.0 car aucune qualification ne peut √™tre √©valu√©e\n\n**Format de sortie (JSON uniquement):**\n{\n  \"qualificationRate\": 0.0,\n  \"explanation\": \"Explication claire en fran√ßais de pourquoi le CV n'a pas pu √™tre analys√© et ce que le candidat doit faire.\"\n}` }];\n  }\n  \n  // Texte valide, analyser normalement\n  return [{ role: 'user', content: `Tu es un Assistant RH IA. Analyse ce CV et fournis un score de qualification.\n\n**Texte du CV (extrait via ${extractionMethod}):**\n${cvText.substring(0, 15000)}\n\n**Candidat:** ${preparedData.fullName}\n**Email:** ${preparedData.email}\n\n**Exigences du poste:**\n${preparedData.jobRequirements}\n\n**Instructions:**\n1. Score de 0.0 √† 1.0\n2. Exigences principales manquantes = maximum 0.6\n3. Toutes les exigences principales = minimum 0.75\n4. Fournis une explication d√©taill√©e en fran√ßais\n5. Analyse en profondeur les comp√©tences, exp√©riences et qualifications du candidat\n6. Compare avec les exigences du poste\n7. Sois pr√©cis et d√©taill√© dans ton analyse\n\n**Format de sortie (JSON uniquement, explication en fran√ßais):**\n{\n  \"qualificationRate\": 0.85,\n  \"explanation\": \"Analyse d√©taill√©e en fran√ßais des qualifications du candidat, de ses comp√©tences, de son exp√©rience et de sa correspondance avec les exigences du poste.\"\n}` }];\n})() }}"
            }
          ]
        },
        "options": {}
      },
      "id": "call-openrouter-ai",
      "name": "Call OpenRouter AI",
      "type": "n8n-nodes-base.httpRequest",
      "position": [1625, 300],
      "typeVersion": 4.2,
      "disabled": false,
      "credentials": {
        "openRouterApi": {
          "id": "ADMIN_OPENROUTER_CREDENTIAL_ID",
          "name": "ADMIN_OPENROUTER_CREDENTIAL_NAME"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// NODE 6: PARSE AI RESULT (apr√®s Call OpenRouter AI)\n// =====================================================\nconst aiResponse = $input.item.json;\nconst mergedData = $('Merge Text Results').item.json;\n\nconsole.log('ü§ñ [PARSE AI] Parsing AI response...');\n\nlet analysis = {\n  qualificationRate: 0,\n  explanation: 'Erreur de parsing'\n};\n\ntry {\n  let content = '';\n  \n  if (aiResponse.choices?.[0]?.message?.content) {\n    content = aiResponse.choices[0].message.content;\n  } else if (aiResponse.message?.content) {\n    content = aiResponse.message.content;\n  } else if (typeof aiResponse === 'string') {\n    content = aiResponse;\n  } else {\n    throw new Error('AI response structure invalid');\n  }\n  \n  console.log(`üìÑ [PARSE AI] Content length: ${content.length}`);\n  \n  let parsed = null;\n  \n  const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    try {\n      parsed = JSON.parse(jsonMatch[0]);\n    } catch (e) {}\n  }\n  \n  if (!parsed) {\n    try {\n      parsed = JSON.parse(content.trim());\n    } catch (e) {}\n  }\n  \n  if (!parsed) {\n    const codeMatch = content.match(/```(?:json)?\\s*\\n?\\s*(\\{[\\s\\S]*?\\})\\s*\\n?\\s*```/);\n    if (codeMatch) {\n      try {\n        parsed = JSON.parse(codeMatch[1]);\n      } catch (e) {}\n    }\n  }\n  \n  if (parsed) {\n    analysis = {\n      qualificationRate: parsed.qualificationRate ?? parsed.score ?? 0,\n      explanation: parsed.explanation ?? parsed.reason ?? parsed.analysis ?? 'Analyse effectu√©e'\n    };\n  } else {\n    const scoreMatch = content.match(/(?:qualificationRate|score)[:\\s]*([0-9.]+)/i);\n    if (scoreMatch) {\n      let score = parseFloat(scoreMatch[1]);\n      analysis.qualificationRate = score > 1 ? score / 100 : score;\n    }\n    analysis.explanation = content.substring(0, 2000);\n  }\n  \n} catch (e) {\n  console.error('‚ùå [PARSE AI] Error:', e.message);\n  analysis.explanation = `Erreur lors de l'analyse: ${e.message}`;\n}\n\nanalysis.qualificationRate = Math.max(0, Math.min(1, analysis.qualificationRate));\n\nconsole.log(`‚úÖ [PARSE AI] Score: ${analysis.qualificationRate}, Explanation: ${analysis.explanation.length} chars`);\n\nreturn {\n  json: {\n    qualificationRate: analysis.qualificationRate,\n    explanation: analysis.explanation,\n    extractedText: mergedData.text?.substring(0, 5000) || '',\n    fullName: mergedData.fullName,\n    email: mergedData.email,\n    notificationEmail: mergedData.notificationEmail\n  }\n};"
      },
      "id": "parse-ai-result",
      "name": "Parse AI Result",
      "type": "n8n-nodes-base.code",
      "position": [1875, 300],
      "typeVersion": 2,
      "disabled": false
    },
    {
      "parameters": {
        "fromEmail": "admin@heleam.com",
        "toEmail": "={{ $json.notificationEmail || $json.email }}",
        "subject": "=R√©sultats de l'analyse CV - {{ $json.fullName }}",
        "html": "=<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <style>\n    body { font-family: Arial, sans-serif; background: #f9fafb; color: #23272f; }\n    .container { max-width: 600px; margin: 20px auto; background: #fff; border-radius: 10px; box-shadow: 0 2px 6px #dedede; padding: 24px; }\n    h2 { color: #2d5016; margin-top: 0; }\n    p { margin: 10px 0; }\n    strong { color: #2d5016; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <h2>R√©sultats de l'analyse CV</h2>\n    <p><strong>Candidat:</strong> {{ $json.fullName || 'N/A' }}</p>\n    <p><strong>Email:</strong> {{ $json.email || 'N/A' }}</p>\n    <p><strong>Taux de qualification:</strong> {{ Math.round(($json.qualificationRate || 0) * 100) }}%</p>\n    <p><strong>Explication:</strong></p>\n    <p>{{ $json.explanation || 'Aucune explication disponible' }}</p>\n  </div>\n</body>\n</html>",
        "options": {}
      },
      "id": "send-email-report",
      "name": "Send Email Report",
      "type": "n8n-nodes-base.emailSend",
      "position": [2125, 300],
      "typeVersion": 2.1,
      "disabled": false,
      "credentials": {
        "smtp": {
          "id": "ADMIN_SMTP_CREDENTIAL_ID",
          "name": "ADMIN_SMTP_CREDENTIAL_NAME"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, candidate: $json.fullName, score: $json.qualificationRate, emailSent: true } }}",
        "options": {}
      },
      "id": "webhook-response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "position": [2375, 300],
      "typeVersion": 1.1,
      "disabled": false
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook Trigger (AUTOMIVY)": {
      "main": [
        [
          {
            "node": "Prepare CV Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare CV Data": {
      "main": [
        [
          {
            "node": "Extract PDF Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract PDF Text": {
      "main": [
        [
          {
            "node": "Normalize Extracted Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Extracted Text": {
      "main": [
        [
          {
            "node": "Check Needs OCR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Needs OCR": {
      "main": [
        [
          {
            "node": "Prepare OCR",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge Text Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare OCR": {
      "main": [
        [
          {
            "node": "OCR with OCR.space",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OCR with OCR.space": {
      "main": [
        [
          {
            "node": "Parse OCR Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse OCR Result": {
      "main": [
        [
          {
            "node": "Merge Text Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Text Results": {
      "main": [
        [
          {
            "node": "Call OpenRouter AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call OpenRouter AI": {
      "main": [
        [
          {
            "node": "Parse AI Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Result": {
      "main": [
        [
          {
            "node": "Send Email Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Email Report": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1"
}
